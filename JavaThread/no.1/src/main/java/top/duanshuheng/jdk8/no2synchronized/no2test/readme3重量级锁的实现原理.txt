线程在运行synchronized代码时，发现锁是轻量锁且被占用，则会触发锁膨胀升级到重量级锁。
获取重量级锁过程中，会先触发锁膨胀。
锁膨胀的意义就是构建一个ObjectMonitor

获取重量级锁：
    在锁的方法中首先会创建一个ObjectMonitor对象，把此对象指针保存到lock锁对象的Mark Word中。
        如果当前锁是重量级锁：
            不需要再膨胀，直接从锁对象的Mark Word中获取ObjectMonitor对象的指针返回即可。
        如果有其他线程正在进行锁膨胀：
            就通过自旋的方式不断重试，直到其他线程完成锁膨胀。
        如果当前其他线程获得了轻量级锁：
            当前的线程完成锁膨胀。
        如果当前是无锁状态：
            之前占用锁的线程正好释放，由于当前线程已经是锁膨胀逻辑，需要完成锁膨胀。
        *都是自旋完成，避免了线程竞争导致CAS失败问题
重量级锁的竞争：
    都是在ObjectMonitor完成的，重要字段如下：
        _owner      当前持有锁的线程
        _object     保存锁对象的指针
        _cxq        储存没有获得锁的线程队列（链表）
        _WaitSet    调用Object.wait()方法阻塞时，被阻塞的线程会保存到该队列中
        _recursions 记录重入次数
    获取：
        判断线程是否重入，是就增加次数
        通过自旋锁来实现锁的抢占，用CAS机制判断ObjectMonitor的_owner是否为空：
            _owner为空：
                重量级锁已经释放，当前线程可获得此锁
            _owner不为空：
                继续通过自适应自旋重试获得锁
        如果自旋锁竞争失败，将当前线程构建成ObjectWaiter，并插入_cxq的队首，再用pack阻塞当前线程。
    *虽然很多人描述自旋锁是在轻量级锁中完成的，但是在Hotspot 1.8源码中，轻量级锁没有使用自旋操作

    释放：
        ObjectMonitor的_owner置为null。
        _cxq中唤醒一个阻塞的线程
        被唤醒线程会参与重量级锁的竞争（非公平锁，如果没有抢到继续等待）

用户态和内核态：
    *表示不同的执行权限：
        用户态：
            用户空间的进程不能直接访问操作系统内核的指令和程序
        内核态：
            运行在内核空间的程序可以访问系统内核的数据结构和程序
    重量级锁中， 线程的阻塞和唤醒是使用park()和unpark()方法，他们在不同的操作系统有不同的实现
    在os_linux.cpp中：
        park()：
            关注三个方法：
                pthread_mutex_lock()
                    锁定_mutext指向的互斥锁，如果此锁被另外个线程锁定和拥有，则当前调用方法的线程会被阻塞，直到互斥锁变可用
                pthread_mutex_wait()
                    条件等待
                pthread_mutex_unlock()
                    释放指定_mutex应用的互斥锁对象
    park()方法需要系统调用完成，显然只能在内核空间完成，所以会有用户态到内核态的切换：
        保存用户态的状态、寄存器、程序指令等
        然后执行系统调用
        恢复用户态执行






