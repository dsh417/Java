为了解决synchronized的阻塞（用户态->内核态）

通过自旋来解决短时间内可能会获得锁的情况
AtomicInteger通过do while不断对value进行累加，累加成功便返回

jvm的synchronized的话，用的是for循环实现自旋锁，虽然这部分是C++写的
    但是具体CAS的底层是基于汇编指令cmpxhgl从主存里面进行比较替换操作，在多核心状态下其实也不是原子性的，所以底层必然用了Lock锁实现
    要保证两个事情：指令的原子性，禁止指令前后读写重排


问题： 如果多个线程调用CAS，并且多个线程都去执行预期值与实际值的判断，仍然存在原子性问题
回答： 要来到unsafe.cpp（跨平台原因，这里没有实现，不同的操作系统是用不同.hpp文件实现的）