JDK1.6以后加的偏向锁

   可以认为是在没有多线程竞争的情况下访问synchronized的场景
   Q:没有线程竞争为什么加锁？
   A：加锁是为了防范线程安全性的风险，有没有线程竞争不由我们来控制，而是由应用场景来决定，假设这种情况存在，用重量级锁基于操作系统的Mutex Lock实现锁的抢占，其实很浪费性能

   偏向锁的作用是，没有线程竞争的情况下，访问synchronized同代码块时，会先尝试偏向锁来抢占访问资格
   如果线程X获得了偏向锁，在线程x后续访问这个同步锁的话，只需要判断对象头（Klass Pointer）的线程id和线程x是否相等即可，相等就不需要再次抢占锁，直接获得访问资格。

   例子：
   BiasedLockExample
   
   在线程没有没有竞争时，偏向锁能在能在不影响性能的前提下，获得锁资源，但是同一时刻，只允许一个线程获得锁资源。
   如果突然有多个线程来访问同步方法，没有抢占到锁资源的怎么办呢，偏向锁解决不了问题：
   正常情况就是阻塞线程，等待唤醒（重量级锁的方法）
   轻量级锁就是更平衡的解决方法
    如果线程没有抢到锁， 会通过多次重试，也就是自旋来尝试获得锁
    对于锁被占用时间少的情况来讲，自旋锁带来的性能提升高，但是如果占有时间长，由于cpu是一直在运行的，会导致大量的性能浪费，所以在重试几次失败后，线程会转为重量级锁（被阻塞）。

