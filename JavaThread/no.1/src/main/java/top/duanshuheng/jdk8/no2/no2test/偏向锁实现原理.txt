BasicObjectLock
下文称为Lock Record

线程私有的数据结构
    两个属性
    BasicLock：有一个字段markOop，保存指向lock锁对象的[对象头]数据（即访问代码块的线程）
    oop：      指向lock锁对象的指针

每个线程都有一个Lock Record列表，每一个Lock Record都会关联到锁对象的lock的Mark Word

原理（没有锁竞争情况）：
    线程访问到synchronized(lock)代码块：
        从线程桟找到空的BasicObjectLock，将oop指针指向当前的锁对象lock；
        通过对象头判断是否可偏向，并且Thread Id为空：
            判断可偏向：
                Y：线程Id偏向自己，直接获得访问资格
                N：不可偏向状态，需要轻量锁来抢占锁：
                    如果当前对象锁lock偏向其他线程、匿名偏向状态：
                        构建个匿名的Mark Word（锁的状态），通过CAS方法，将对象锁的匿名偏向的Mark Word修改为偏向自己的线程。
                        （如果此时锁对象偏向了其他线程，CAS一定会失败）

原理（存在锁竞争）：
    线程1访问synchronized(lock)代码块：
        触发锁竞争、且撤销偏向锁：
            撤销偏向锁：
                线程1调用撤销偏向锁方法，尝试撤销lock锁对象的偏向锁（因为偏向锁用于无锁竞争情况，这里显然违背）
                撤销时机：
                        *偏向锁要到全局安全点（SafePoint）才执行，此时会[暂停]获得偏向锁的【线程0】(不是线程自己，而是原本获取到偏向锁的线程)
                        *全局安全点：线程状态可以确定，堆的状态也是确定，JVM可以安全的GC。
                    线程1已经执行完同步代码块、或者处于非存活状态：
                        1->>偏向锁撤销，恢复无锁状态。
                        2->>线程1升级为轻量级锁，参与锁竞争。
