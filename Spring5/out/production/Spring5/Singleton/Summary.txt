单例模式
目的：内存里只有一个实例，减少内存开销，避免对资源的多重占用

经典的有懒汉式和饿汉式实现方法，区别在一个加载类的时候就初始化，一个在外部类调用的时候 内部类才加载；
    直接就初始化会导致内存浪费，使用加载内部类的方式会存在一个线程安全问题
           虽然可以通过给方法上锁来解决，但是在性能上又会存在问题

    所以就有个双检锁的单例
        通过给单例成员上volatile锁，在getInstance方法内部上synchronized锁，这样由类的阻塞，变成了方法内部的阻塞

    但是这些总归是上锁，对性能肯定有影响，我们通过类初始化的角度，用静态内部类就可以解决上锁问题
        在getInstance方法中，由静态内部类new并且返回一个static fianl的单例成员就可以解决

        同时为了防止反射破坏单例，可以在构造方法里做一个限制，重复创建就直接抛异常
        然后防止序列化破坏单例，可以增加readResolve()方法，返回静态内部类的成员即可

        但其实readResolve()方法其实实例化了两次，只是新创建的对象没有返回而已，如果见对象动作频率高，可能会出现内存问题

        （*readResolve方法其实是 先判断构造方法是否为空，不为空就实例化）

    然后是注册式单例
    第一个是枚举单例，属于加载类就实例化的方式，而且在jdk语法上就为枚举保驾护航了。
        无论用反射还是序列化都没法破坏枚举单例。
        （如果想用反射破坏枚举类的话，在newInstance里就有一个判断,修饰符是枚举类就抛异常）
        （如果想用序列化破坏枚举类的话，不可能，因为枚举对象就是通过类名和类对象找到唯一一个枚举对象，所以 枚举对象不能被加载多次）

    第二个是容器式单例
        通过类名创建单例，并且存储在静态成员的哈希表中完成，方便管理，但是它是非线程安全的。
        spring用的就是容器单例

    最后的线程单例实现ThreadLocal算是彩蛋

