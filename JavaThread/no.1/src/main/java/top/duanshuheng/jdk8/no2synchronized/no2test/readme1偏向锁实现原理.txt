BasicObjectLock
下文称为Lock Record

线程私有的数据结构
    两个属性
    BasicLock：有一个字段markOop，保存指向lock锁对象的[对象头]数据
    oop：      指向lock锁对象的指针

每个线程都有一个Lock Record列表，每一个Lock Record都会关联到锁对象的lock的Mark Word

原理（没有锁竞争情况）：
    线程访问到synchronized(lock)代码块：
        从线程桟找到空的BasicObjectLock，将oop指针指向当前的锁对象lock；
        通过对象头判断是否可偏向：
            可偏向：判断Thread Id偏向自己线程：
                Y：线程Id偏向自己，直接获得访问资格
                N：没有偏向自己，需要通过轻量锁来抢占锁：
            不可偏向：
                同样通过轻量锁来抢占锁
        如果当前对象锁lock偏向其他线程、匿名偏向状态：
            构建个匿名的Mark Word，通过CAS方法，将对象锁的Mark Word修改为偏向自己的线程。
            （如果此时锁对象偏向了其他线程，CAS一定会失败，失败则表明存在锁竞争，偏向锁需要撤销）

原理（存在锁竞争）：
    线程1访问synchronized(lock)代码块：
        触发锁竞争、且撤销偏向锁：
            撤销偏向锁：
                线程1调用撤销偏向锁方法，尝试撤销lock锁对象的偏向锁（因为偏向锁用于无锁竞争情况，这里显然违背）
                撤销时机：
                    *偏向锁要到全局安全点（SafePoint）才执行，此时会[暂停]获得偏向锁的【线程0】(不是线程自己，而是原本获取到偏向锁的线程)
                    *全局安全点：线程状态可以确定，堆的状态也是确定，JVM可以安全的GC。
                    处于安全点：
                        线程0已经执行完同步代码块、或者处于非存活状态：
                            1->>偏向锁撤销，恢复无锁状态。
                            2->>线程1升级为轻量级锁，参与锁竞争。
                        线程0还在执行同步代码块：
                            锁对象lock直接升级为轻量级锁（这里是全局安全点，不需要CAS），并且指向线程0，标识线程0拥有轻量级锁，线程0继续执行。

偏向锁的释放：
    偏向锁执行完synchronized代码后，会释放偏向锁，但是偏向锁本质上没有释放，锁对象lock仍然指向偏向线程。【锁对象仍然指向线程】
    仅仅是线程的BasicObjectLock保存的锁对象的Mark Word置空。【线程的BasicObjectLock对象头的Mark Word置空】

批量重偏向：
    默认20次，当线程0对大量锁对象增加了偏向锁，之后线程1来访问这些锁对象，无线程竞争的话，会批量的对偏向线程0的对象锁进行撤销和升级，这是非常消耗性能的，
    所以在一定数量后，会将所有锁对象偏向线程1.