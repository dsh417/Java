为了解决synchronized的阻塞（用户态->内核态）

通过自旋来解决短时间内可能会获得锁的情况
AtomicInteger通过do while不断对value进行累加，累加成功便返回

jvm的synchronized的重量级锁实现的话，用的是for循环实现自旋锁，然后使用Atomic::acmpxchg_ptr进行抢占的


问题： 如果多个线程调用CAS，并且多个线程都去执行预期值与实际值的判断，仍然存在原子性问题
回答： 要来到unsafe.cpp（跨平台原因，这里没有实现，不同的操作系统是用不同.hpp文件实现的）

实现自旋锁的条件：
    for循环不断重试
    通过一个线程安全的操作去抢占资源，CAS就是很好的方法，通过CAS满足原子操作的方法返回ture、false，可以判断线程竞争的结果。

JVM实现CAS是在unsafe.cpp文件里，他通过传递的对象指针，指针偏移量，和你要比较的数据，通过数据比对。成功的话就修改对象的值。这部分其实也体现了C++指针的灵活性，直接操作内存数据。
    由于JVM是跨平台的，所以对于不同系统有不同的实现hpp文件，linux的话，
    底层是基于汇编指令cmpxhgl从主存里面进行比较替换操作，在多核心状态下其实也不是原子性的，所以底层必然用了Lock锁实现
    因为要保证两个事情：指令的原子性，禁止指令前后读写重排